<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="keywords" content="Spring的AOP, 编程技术, Spring, 逆水行舟" />
    <meta name="description" content="Spring的AOP, 编程技术, Spring, 在Spring中使用AOP的详细资料可以查看这里" />

    <title>逆水行舟</title>

    <!-- ico图标 -->
    <link rel="shortcut icon" type="image/x-icon" media="screen" href="/static/favicon.ico" />
    <!-- 搜索引擎收入相关 -->
    <link rel="canonical" href="http://loveshisong.cn/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015-11-26-Spring%E7%9A%84AOP.html" />
    <!-- rss输出源 -->
    <link rel="alternate" type="application/rss+xml" title="逆水行舟" href="http://loveshisong.cn/feed.xml"  />
    <!-- jquery -->
    <script type="text/javascript" src="http://apps.bdimg.com/libs/jquery/1.11.3/jquery.js"></script>
    <!-- qrcode -->
    <script type="text/javascript" src="/static/js/jquery.qrcode.min.js"></script>
    <!-- UK core js -->
    <script type="text/javascript" src="/static/js/uikit.min.js"></script>
    <!-- quietflow -->
    <!-- <script type="text/javascript" src="http://loveshisong.cn/static/js/quietflow.min.js"></script> -->
    <!-- UK sticky -->
    <script type="text/javascript" src="/static/js/components/sticky.min.js"></script>
    <!-- 本站js -->
    <script type="text/javascript" src="/static/js/script.js"></script>
    <!-- uk css-->
    <link rel="stylesheet" type="text/css" href="/static/css/uikit.min.css" />
    <!-- 基本样式 -->
    <link rel="stylesheet" type="text/css" href="/static/css/base.css" />
    <!-- 本站样式 -->
    <link rel="stylesheet" type="text/css" href="/static/css/main.css" />
    <!-- 代码高亮 -->
    <link rel="stylesheet" type="text/css" href="/static/css/highlight.css" />

    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
        var duoshuoQuery = {
            short_name: "shisong"
        };
        (function() {
            var ds = document.createElement('script');
            ds.type = 'text/javascript';
            ds.async = true;
            ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
            ds.charset = 'UTF-8';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
        })();
    </script>
    <!-- 多说公共JS代码 end -->
</head>


<body>

    <header class="header" data-uk-sticky>
    <!-- 导航栏 -->
    <div class="uk-container uk-container-center">
        <div class="headwapper">
            <div class="navbar uk-float-left">
                <a class="uk-navbar-brand uk-hidden-small" href="http://loveshisong.cn"> 逆水行舟 -- Michael King's Blog </a>
                <a class="uk-visible-small uk-icon-home uk-icon-large" href="http://loveshisong.cn"></a>
            </div>
            <div class="navbar uk-float-right">
                <ul class="navbar-nav">
                    <li><a href="/pages/archive.html" title="归档" class="uk-icon-folder uk-icon-small"></a></li>
                    <li><a href="/pages/categories.html" title="目录分类" class="uk-icon-list uk-icon-small"></a></li>
                    <li><a href="/pages/tags.html" title="标签" class="uk-icon-tags uk-icon-small"></a></li>
                    <li><a href="/pages/about.html" title="About Me" class="uk-icon-user uk-icon-small"></a></li>
                    <li><a href="https://github.com/rgkjhshi" title="Github" class="uk-icon-github uk-icon-small"></a></li>
                    <li><a href="/feed.xml" title="RSS" class="uk-icon-rss uk-icon-small"></a></li>
                </ul>
            </div>
        <div>
    </div>
</header>
<!-- header end -->


    <div class="uk-container uk-container-center">
        <script type="text/javascript">
jQuery(function(){
	jQuery('#qrcode').qrcode({
        width: 150,
        height: 150,
        text: "http://loveshisong.cn/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015-11-26-Spring%E7%9A%84AOP.html"
    });
})
</script>
<!-- 日志默认模板 -->
<div class="uk-container content">
    <div class="page-title">
        <h1>Spring的AOP</h1>
    </div>
    <div class="uk-grid">
        <div  class="uk-width-4-4">
            <div id="qrcode" class="uk-float-right uk-thumbnail"></div>
            <p>在Spring中使用AOP的详细资料可以查看<a href="http://shouce.jb51.net/spring/aop.html">这里</a></p>

<hr />

<ul id="markdown-toc">
  <li><a href="#aop">AOP的实现方式</a></li>
  <li><a href="#aopcglibspring-aopaspectj">AOP、CGLib、Spring AOP、AspectJ之间的关系</a></li>
  <li><a href="#springaop">Spring中AOP相关的概念</a></li>
  <li><a href="#aspectj">启用@AspectJ支持</a></li>
  <li><a href="#section">声明一个切面</a></li>
  <li><a href="#section-1">声明一个切入点</a></li>
  <li><a href="#section-2">声明通知</a></li>
  <li><a href="#section-3">通知参数</a></li>
  <li><a href="#section-4">切入点表达式</a></li>
  <li><a href="#section-5">切入点表达式示例</a></li>
</ul>

<hr />

<h2 id="aop">AOP的实现方式</h2>
<p>在Java中,从织入切面的方式上来看,存在三种织入方式:编译时织入、加载时织入和运行时织入</p>

<ul>
  <li>编译时织入(Compile Time Weaving, CTW)</li>
</ul>

<p>指在Java编译期,采用特殊的编译器, 将切面织入到Java类中,即发生在从java文件到class文件的过程.<br />
这种方式将切面直接编译进了字节码，所以运行时不再需要动态创建代理对象, 节约了内存和CPU, 但编译过程复杂(可借助Maven AspectJ插件)，编写aspect文件(.aj文件)复杂</p>

<ul>
  <li>加载时织入(Load Time Weaving, LTW)</li>
</ul>

<p>指通过特殊的类加载器(如AspectJ compiler), 在JVM载入字节码文件时, 织入切面, 即发生在class文件加载的过程.<br />
具体可参考<a href="http://shouce.jb51.net/spring/aop.html#aop-aj-ltw">这里</a></p>

<ul>
  <li>运行时织入</li>
</ul>

<p>采用CGLib工具或JDK动态代理进行切面的织入, 如Spring AOP</p>

<hr />

<h2 id="aopcglibspring-aopaspectj">AOP、CGLib、Spring AOP、AspectJ之间的关系</h2>

<ul>
  <li>AOP, Aspect Oriented Programming, 面向切面编程,是个概念, 类似于面向对象编程(OOP)一样</li>
  <li>CGLib, 基于<code class="highlighter-rouge">asm.jar</code>的字节码增强技术API, 开源的, 也是个jar包:<code class="highlighter-rouge">cglib.jar</code></li>
  <li>Spring AOP, Spring的AOP实现, 在运行时基于动态代理(JDK或cglib)的方式进行织入, Spring3.2以后不再需要依赖<code class="highlighter-rouge">cglib.jar</code>包, 因为它里面的类已经被<code class="highlighter-rouge">spring-core.jar</code>包含了</li>
  <li>AspectJ, 提供了完整的AOP实现
    <ol>
      <li>AspectJ是一个代码生成工具,于自己的语法编译工具，编译的结果是Java Class文件, 支持编译时织入切面，即所谓的CTW机制</li>
      <li>AspectJ有自己的类装载器，支持在类装载时织入切面，即所谓的LTW机制</li>
      <li>AspectJ同样也支持运行时织入，运行时织入是基于动态代理的(默认机制)</li>
    </ol>
  </li>
</ul>

<hr />

<h2 id="springaop">Spring中AOP相关的概念</h2>
<p>在怎么使用之前,最好先看看相关概念,有关<code class="highlighter-rouge">Joinpoint</code>、<code class="highlighter-rouge">Pointcut</code>、<code class="highlighter-rouge">Advice</code>等概念,看<a href="http://shouce.jb51.net/spring/aop.html#aop-introduction-defn">这里</a></p>

<h2 id="aspectj">启用@AspectJ支持</h2>
<p>在Spring中使用<code class="highlighter-rouge">@AspectJ</code>可以在配置文件中启用<code class="highlighter-rouge">&lt;aop:aspectj-autoproxy/&gt;</code>, 甚至启用LTW机制<code class="highlighter-rouge">&lt;context:load-time-weaver/&gt;</code>, 对应的注解分别为<code class="highlighter-rouge">@EnableAspectJAutoProxy</code>和<code class="highlighter-rouge">@EnableLoadTimeWeaving</code></p>

<h2 id="section">声明一个切面</h2>
<p>在带有<code class="highlighter-rouge">@AspectJ</code>注解的类上同时加上<code class="highlighter-rouge">@Component</code>(声明为一个bean)注解并确保被自动扫描, 这样才会被Spring识别并管理</p>

<h2 id="section-1">声明一个切入点</h2>
<p>切入点决定了连接点关注的内容，使得我们可以控制通知什么时候执行, 即从哪里把要做的操作(通知)切入进去<br />
一个切入点声明有两个部分: <em>切入点签名</em> 和 <em>切入点表达式</em><br />
在<code class="highlighter-rouge">@AspectJ</code>注解风格的AOP中, <em>切入点签名</em> 通过一个普通的方法定义来提供, 该方法必需反回<code class="highlighter-rouge">void</code>类型;<br />
<em>切入点表达式</em> 使用<code class="highlighter-rouge">@Pointcut</code>注解来表示(内容略多, 后面讲), 一个切入点声明如下:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="nd">@Pointcut</span><span class="o">(</span><span class="n">value</span><span class="o">=</span><span class="s">"execution(* sayAdvisorBefore(..)) &amp;&amp; args(param)"</span><span class="o">,</span> <span class="n">argNames</span> <span class="o">=</span> <span class="s">"param"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">pointcutName</span><span class="p">(</span><span class="n">String</span> <span class="n">param</span><span class="o">)</span> <span class="o">{}</span>
</code></pre>
</div>

<ul>
  <li>value: 指定切入点表达式, 如<code class="highlighter-rouge">execution</code>、<code class="highlighter-rouge">args</code>等</li>
  <li>argNames: 指定该切入点方法参数列表,多个用<code class="highlighter-rouge">,</code>分隔,这些参数将传递给通知方法同名的参数;</li>
  <li>pointcutName: 切入点名字，可以用该名字引用该切入点表达式</li>
</ul>

<h2 id="section-2">声明通知</h2>
<p><code class="highlighter-rouge">@AspectJ</code>风格的声明通知支持5种通知类型:</p>

<ul>
  <li><code class="highlighter-rouge">@Before</code>: 前置通知,执行连接点方法之前执行</li>
  <li><code class="highlighter-rouge">@AfterReturning</code>: 后置返回通知, 一个匹配的方法返回的时候执行</li>
  <li><code class="highlighter-rouge">@AfterThrowing</code>: 异常通知, 在一个方法抛出异常后执行</li>
  <li><code class="highlighter-rouge">@After</code>: 最终通知, 不论一个方法是如何结束的,最终通知都会运行, 最终通知必须准备处理正常返回和异常返回两种情况</li>
  <li><code class="highlighter-rouge">@Around</code>: 环绕通知, 在一个方法执行之前和之后执行, 而且它可以决定这个方法在什么时候执行，如何执行，甚至是否执行. 通知的第一个参数必须是<code class="highlighter-rouge">ProceedingJoinPoint</code>类型,在通知体内，调用<code class="highlighter-rouge">ProceedingJoinPoint</code>的<code class="highlighter-rouge">proceed()</code>方法会导致 后台的连接点方法执行</li>
</ul>

<p>如果在同一个连接点上执行多个通知,可以使用<code class="highlighter-rouge">@Order</code>注解决定其执行顺序</p>

<p>下面是通知的使用方式:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="nd">@Before</span><span class="o">(</span><span class="n">value</span> <span class="o">=</span> <span class="s">"切入点表达式或命名切入点"</span><span class="o">,</span> <span class="n">argNames</span> <span class="o">=</span> <span class="s">"参数列表参数名"</span><span class="o">)</span>
<span class="nd">@After</span><span class="o">(</span><span class="n">value</span>  <span class="o">=</span> <span class="s">"切入点表达式或命名切入点"</span><span class="o">,</span> <span class="n">argNames</span> <span class="o">=</span> <span class="s">"参数列表参数名"</span><span class="o">)</span>
<span class="nd">@Around</span><span class="o">(</span><span class="n">value</span> <span class="o">=</span> <span class="s">"切入点表达式或命名切入点"</span><span class="o">,</span> <span class="n">argNames</span> <span class="o">=</span> <span class="s">"参数列表参数名"</span><span class="o">)</span>
<span class="nd">@AfterReturning</span><span class="o">(</span>
<span class="n">value</span> <span class="o">=</span> <span class="s">"切入点表达式或命名切入点"</span><span class="o">,</span>
<span class="n">pointcut</span> <span class="o">=</span> <span class="s">"切入点表达式或命名切入点"</span><span class="o">,</span> <span class="c1">// 如果指定了将覆盖value属性指定的，pointcut具有高优先级</span>
<span class="n">argNames</span> <span class="o">=</span> <span class="s">"参数列表参数名"</span><span class="o">,</span>
<span class="n">returning</span> <span class="o">=</span> <span class="s">"返回值对应参数名"</span><span class="o">)</span>
<span class="nd">@AfterThrowing</span><span class="o">(</span>
<span class="n">value</span> <span class="o">=</span> <span class="s">"切入点表达式或命名切入点"</span><span class="o">,</span>
<span class="n">pointcut</span> <span class="o">=</span> <span class="s">"切入点表达式或命名切入点"</span><span class="o">,</span>
<span class="n">argNames</span> <span class="o">=</span> <span class="s">"参数列表参数名"</span><span class="o">,</span>
<span class="n">throwing</span> <span class="o">=</span> <span class="s">"异常对应参数名"</span><span class="o">)</span>
</code></pre>
</div>
<p>来个小例子:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="nd">@Aspect</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BeforeExample</span> <span class="o">{</span>
    <span class="nd">@Before</span><span class="o">(</span><span class="n">value</span> <span class="o">=</span> <span class="s">"pointcutName(param)"</span><span class="o">,</span> <span class="n">argNames</span> <span class="o">=</span> <span class="s">"param"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="n">beforeAdvice</span><span class="o">(</span><span class="n">String</span> <span class="n">param</span><span class="o">)</span> <span class="o">{</span>  <span class="c1">// 切入点匹配到的参数将传递过来</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">param</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
</div>
<p>上例使用<code class="highlighter-rouge">@Before</code>进行前置通知声明,其中value用于定义切入点表达式或引用命名切入点</p>

<hr />

<h2 id="section-3">通知参数</h2>
<p>通知方法可以获取被通知方法的参数，主要是通过<code class="highlighter-rouge">JoinPoint</code>(环绕通知是<code class="highlighter-rouge">JoinPoint</code>的子类<code class="highlighter-rouge">ProceedingJoinPoint</code>)来获取, <code class="highlighter-rouge">JoinPoint</code>必须是第一个参数, Spring会自动传入.</p>

<p><code class="highlighter-rouge">JoinPoint</code>的声明如下:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ProceedingJoinPoint</span> <span class="kd">extends</span> <span class="n">JoinPoint</span> <span class="o">{</span>  
    <span class="kd">public</span> <span class="n">Object</span> <span class="n">proceed</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Throwable</span><span class="o">;</span>    <span class="c1">// 执行连接点的方法</span>
    <span class="kd">public</span> <span class="n">Object</span> <span class="n">proceed</span><span class="o">(</span><span class="n">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Throwable</span><span class="o">;</span> <span class="c1">// 执行连接点的方法,可以把原来的参数用新的args替换掉</span>
<span class="o">}</span>
<span class="c1">// 如果我这么声明切点: @Pointcut("within(com.test.spring.bean.Hello))")</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">JoinPoint</span> <span class="o">{</span>  
    <span class="n">String</span> <span class="n">toString</span><span class="o">();</span>          <span class="c1">// execution(String com.test.spring.bean.Hello.hello(String))</span>
    <span class="n">String</span> <span class="n">toShortString</span><span class="o">();</span>     <span class="c1">// execution(Hello.hello(..))</span>
    <span class="n">String</span> <span class="n">toLongString</span><span class="o">();</span>      <span class="c1">// execution(public java.lang.String com.test.spring.bean.Hello.hello(java.lang.String))</span>
    <span class="c1">// 上面这几个toString, 是打印切点相关信息, 注意上面是用 within声明 而打印出来的是 execution.</span>
    <span class="n">Object</span> <span class="n">getThis</span><span class="o">();</span>           <span class="c1">//返回AOP代理对象  </span>
    <span class="n">Object</span> <span class="n">getTarget</span><span class="o">();</span>         <span class="c1">//返回目标对象(被代理的对象)  </span>
    <span class="n">Object</span><span class="o">[]</span> <span class="n">getArgs</span><span class="o">();</span>         <span class="c1">//返回被通知方法参数列表  </span>
    <span class="n">Signature</span> <span class="n">getSignature</span><span class="o">();</span>   <span class="c1">//返回当前连接点签名  </span>
    <span class="n">SourceLocation</span> <span class="n">getSourceLocation</span><span class="o">();</span><span class="c1">//返回连接点方法所在类文件中的位置  </span>
    <span class="n">String</span> <span class="n">getKind</span><span class="o">();</span>           <span class="c1">//连接点类型  </span>
    <span class="n">StaticPart</span> <span class="n">getStaticPart</span><span class="o">();</span> <span class="c1">//返回连接点静态部分</span>
    <span class="c1">// 这是个内部接口, 提供访问连接点的静态部分，如被通知方法签名、连接点类型等</span>
    <span class="kd">public</span> <span class="kd">interface</span> <span class="nc">StaticPart</span> <span class="o">{</span>  
        <span class="n">Signature</span> <span class="n">getSignature</span><span class="o">();</span>    <span class="c1">//返回当前连接点签名  </span>
        <span class="n">String</span> <span class="n">getKind</span><span class="o">();</span>            <span class="c1">//连接点类型  </span>
        <span class="kt">int</span> <span class="n">getId</span><span class="o">();</span>                 <span class="c1">//唯一标识  </span>
        <span class="n">String</span> <span class="n">toString</span><span class="o">();</span>           <span class="c1">//连接点所在位置的相关信息  </span>
        <span class="n">String</span> <span class="n">toShortString</span><span class="o">();</span>      <span class="c1">//连接点所在位置的简短相关信息  </span>
        <span class="n">String</span> <span class="n">toLongString</span><span class="o">();</span>       <span class="c1">//连接点所在位置的全部相关信息  </span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
</div>

<p><code class="highlighter-rouge">Signature</code>中的部分方法说明如下:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Signature</span> <span class="o">{</span>  
    <span class="c1">// Signature代表的是切点处的签名信息</span>
    <span class="n">String</span> <span class="n">toString</span><span class="o">();</span>       <span class="c1">// String com.test.spring.bean.Hello.hello(String)</span>
    <span class="n">String</span> <span class="n">toShortString</span><span class="o">();</span>  <span class="c1">// Hello.hello(..)</span>
    <span class="n">String</span> <span class="n">toLongString</span><span class="o">();</span>   <span class="c1">// public java.lang.String com.test.spring.bean.Hello.hello(java.lang.String)</span>
    <span class="n">String</span> <span class="n">getName</span><span class="o">();</span>        <span class="c1">// hello 可参考:java.lang.reflect.Member.getName</span>
<span class="o">}</span>
</code></pre>
</div>

<hr />

<h2 id="section-4">切入点表达式</h2>
<p>切入点表达式就是组成<code class="highlighter-rouge">@Pointcut</code>注解的值, 用于匹配具体的连接点.<br />
切入点表达式由切入点指示符、类型匹配语句、通配符、组合符组成</p>

<p><strong>切入点指示符(PCD)</strong><br />
在切入点表达式中可以使用如下的AspectJ切入点指示符(PCD):</p>

<ul>
  <li>execution: 匹配方法, 这是最经常的切入点指示符</li>
  <li>within: 匹配特定类型之内的全部方法</li>
  <li>this: 用于匹配当前AOP代理对象类型的连接点,包括接口</li>
  <li>target: 用于匹配当前目标对象类型的连接点,不包括接口</li>
  <li>args: 用于匹配当前执行的方法传入的参数为指定类型的连接点</li>
  <li>@within: 匹配持有指定注解的类型里面的所有方法(注解在类上)</li>
  <li>@target: 用于匹配当前目标对象类型的连接点，其中目标对象持有指定的注解</li>
  <li>@args: 匹配当前执行的方法传入的参数持有指定的注解</li>
  <li>@annotation: 匹配持有指定注解的方法(注解在方法上)</li>
</ul>

<p>看不明白还是看最后面的例子吧</p>

<p><strong>类型匹配语句</strong><br />
类型匹配语句格式像下面这样(带<code class="highlighter-rouge">?</code>的属于可选,可以不写):</p>

<ul>
  <li>对类的匹配: <code class="highlighter-rouge">注解? 类的全限定名字</code></li>
  <li>对方法的匹配: <code class="highlighter-rouge">注解? 修饰符? 返回值类型 类型声明? 方法名(参数列表) 异常列表？</code></li>
</ul>

<p><strong>类型匹配的通配符</strong></p>

<ul>
  <li><code class="highlighter-rouge">*</code>: 匹配任何数量字符；</li>
  <li><code class="highlighter-rouge">..</code>:(两个点)匹配任何数量字符的重复;如在类型模式中匹配任何数量子包,而在方法参数模式中匹配任何数量参数</li>
  <li><code class="highlighter-rouge">+</code>: 匹配指定类型的子类型,仅能作为后缀放在类型模式后边</li>
</ul>

<p><strong>组合切入点表达式</strong><br />
AspectJ使用 与(&amp;&amp;)、或(||)、非(!)来组合切入点表达式, 在xml文件中可使用and、or、not</p>

<h2 id="section-5">切入点表达式示例</h2>

<ul>
  <li><code class="highlighter-rouge">execution</code>使用<code class="highlighter-rouge">execution(方法表达式)</code>匹配方法执行</li>
</ul>

<table>
  <thead>
    <tr>
      <th>表达式</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>public * *(..)</td>
      <td>所有public方法</td>
    </tr>
    <tr>
      <td>* cn.test..IService.*()</td>
      <td>cn.test及子包下IService中任何无参方法</td>
    </tr>
    <tr>
      <td>* cn.test..IService＋.*()</td>
      <td>cn.test及子包下IService及子类中任何无参方法</td>
    </tr>
    <tr>
      <td>* cn.test..IService.*(＊)</td>
      <td>cn.test及子包下IService中只有一个参数的方法</td>
    </tr>
    <tr>
      <td>* cn.test..IService.*(..)</td>
      <td>cn.test及子包下IService中所有方法</td>
    </tr>
    <tr>
      <td>* cn.test..IService.*(java.util.Date)</td>
      <td>cn.test及子包下IService中只有一个Date类型参数的方法</td>
    </tr>
    <tr>
      <td>* cn.test..IService<em>.test</em>(..)</td>
      <td>cn.test及子包下IService前缀类型中test前缀开头的任何方法</td>
    </tr>
    <tr>
      <td>* cn.test..<em>.</em>(..)</td>
      <td>cn.test及子包下任何类的任何方法</td>
    </tr>
    <tr>
      <td>@java.lang.Deprecated * *(..)</td>
      <td>任何持有@Deprecated注解的方法</td>
    </tr>
    <tr>
      <td>@(java.lang.Deprecated &amp;&amp; cn.javass..Secure) * *(..)</td>
      <td>任何持有@java.lang.Deprecated和@ cn.javass..Secure注解的方法</td>
    </tr>
  </tbody>
</table>

<ul>
  <li><code class="highlighter-rouge">within</code>使用<code class="highlighter-rouge">within(类型表达式)</code>匹配指定类型内的方法执行</li>
</ul>

<table>
  <thead>
    <tr>
      <th>表达式</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>within(cn.test..*)</td>
      <td>cn.test及子包下的任何方法</td>
    </tr>
    <tr>
      <td>within(cn.test..IService＋)</td>
      <td>cn.test及子包下IService及子类的任何方法</td>
    </tr>
    <tr>
      <td>within(@cn.test.Secure *)</td>
      <td>cn.test及子包下带有@cn.test.Secure注解的任何类(接口不行)的任何方法</td>
    </tr>
  </tbody>
</table>

<ul>
  <li><code class="highlighter-rouge">this</code>使用<code class="highlighter-rouge">this(类型全限定名)</code>匹配当前AOP代理对象类型的执行方法,包括引入接口,不支持通配符</li>
</ul>

<table>
  <thead>
    <tr>
      <th>表达式</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>this(cn.test.IService)</td>
      <td>当前AOP对象实现了IService接口的任何方法</td>
    </tr>
  </tbody>
</table>

<ul>
  <li><code class="highlighter-rouge">target</code>使用<code class="highlighter-rouge">target(类型全限定名)</code>匹配当前目标对象类型的执行方法,不包括引入接口,不支持通配符</li>
</ul>

<table>
  <thead>
    <tr>
      <th>表达式</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>this(cn.test.IService)</td>
      <td>当前目标对象(非AOP对象)实现了IService接口的任何方法</td>
    </tr>
  </tbody>
</table>

<ul>
  <li><code class="highlighter-rouge">args</code>使用<code class="highlighter-rouge">args(参数类型列表)</code>匹配传入参数(不是声明时的参数)为指定类型的执行方法,参数类型必须是全限定名, 不支持通配符</li>
</ul>

<p>args属于动态切入点，这种切入点开销非常大，非特殊情况最好不要使用</p>

<table>
  <thead>
    <tr>
      <th>表达式</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>args(java.lang.String, ..)</td>
      <td>第一个参数为String,后面有任意个参数的方法</td>
    </tr>
  </tbody>
</table>

<ul>
  <li><code class="highlighter-rouge">@within</code>使用<code class="highlighter-rouge">@within(注解类型全限定名)</code>匹配所有持有指定注解的类里面的方法, 即要把注解加在类上</li>
</ul>

<table>
  <thead>
    <tr>
      <th>表达式</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>@within(cn.test.Secure)</td>
      <td>任何目标对象对应的类型持有Secure注解的类方法</td>
    </tr>
  </tbody>
</table>

<ul>
  <li><code class="highlighter-rouge">@target</code>使用<code class="highlighter-rouge">@target(注解类型全限定名)</code>匹配当前目标对象类型的执行方法, 必须是在目标对象上声明注解，在接口上声明不起作用</li>
</ul>

<table>
  <thead>
    <tr>
      <th>表达式</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>@target(cn.test.Secure)</td>
      <td>任何目标对象对应的类型持有Secure注解的类方法</td>
    </tr>
  </tbody>
</table>

<ul>
  <li><code class="highlighter-rouge">@args</code>使用<code class="highlighter-rouge">@args(注解类型全限定名)</code>匹配当前执行的方法传入的参数持有指定注解的执行</li>
</ul>

<table>
  <thead>
    <tr>
      <th>表达式</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>@args(cn.test.Secure)</td>
      <td>任何只接受一个参数的方法，且方法运行时传入的参数持有Secure注解</td>
    </tr>
  </tbody>
</table>

<ul>
  <li><code class="highlighter-rouge">@annotation</code>使用<code class="highlighter-rouge">@annotation(注解类型全限定名)</code>匹配持有指定注解的方法, 即要把注解加在方法上才管用</li>
</ul>

<table>
  <thead>
    <tr>
      <th>表达式</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>@annotation(cn.test.Secure)</td>
      <td>当前执行方法上持有Secure注解的方法</td>
    </tr>
  </tbody>
</table>

<hr />

        </div>
    </div>

    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <div class="ds-thread" data-thread-key="/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/Spring的AOP" data-title="Spring的AOP" data-url="/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015-11-26-Spring%E7%9A%84AOP.html"></div>
    <!-- 多说评论框 end -->
</div>

    </div>

    <!-- 回到顶部 -->
    <div class="page-scrollTop" data-toggle="tooltip" data-placement="top" title="Top">
        <a href="javascript:void(0);">
            <div class="arrow"></div>
            <div class="stick"></div>
        </a>
    </div>

    <footer class="footer">
    <!-- 导航栏 -->
    <div class="uk-container uk-container-center">
        <div class="uk-container footwapper">
            <div class="uk-grid">
                <div class="uk-width-1-3 uk-text-center">
                    <span class="foot-text"> 京ICP备14015515号-1 </span>
                </div>
                <div class="uk-width-1-3 uk-text-center">
                    <span class="foot-text">
                        <a href="http://www.amazingcounters.com"><img border="0" src="http://cc.amazingcounters.com/counter.php?i=3195706&c=9587431" alt="AmazingCounters.com"></a>
                    </span>
                </div>
                <div class="uk-width-1-3 uk-text-center">
                <span class="foot-text"> <i class="uk-icon-copyright"></i>2015 Michael King. </span>
                </div>
                <div class="uk-hidden">
                    <span class="foot-text">
                        <!-- cnzz统计工具 -->
                        <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1254308303'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s4.cnzz.com/z_stat.php%3Fid%3D1254308303%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));</script>
                    </span>
                </div>
            </div>
        </div>
    </div>
</footer>
<!-- footer end -->


</body>

</html>
