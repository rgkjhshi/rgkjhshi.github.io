<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="keywords" content="Docker学习笔记(三):网络和数据卷, 编程技术, Docker, 逆水行舟" />
  <meta name="description" content="Docker学习笔记(三):网络和数据卷, 编程技术, Docker, "
  />

  <title>逆水行舟</title>

  <!-- ico图标 -->
  <link rel="shortcut icon" type="image/x-icon" media="screen" href="/static/favicon.ico" />
  <!-- 搜索引擎收入相关 -->
  <link rel="canonical" href="http://loveshisong.cn/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2016-07-21-Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%89)-%E7%BD%91%E7%BB%9C%E5%92%8C%E6%95%B0%E6%8D%AE%E5%8D%B7.html" />
  <!-- rss输出源 -->
  <link rel="alternate" type="application/rss+xml" title="逆水行舟" href="http://loveshisong.cn/feed.xml" />
  <!-- jquery -->
  <script type="text/javascript" src="http://apps.bdimg.com/libs/jquery/1.11.3/jquery.js"></script>
  <!-- qrcode -->
  <!-- <script type="text/javascript" src="/static/js/jquery.qrcode.min.js"></script> -->
  <!-- UK core js -->
  <script type="text/javascript" src="/static/js/uikit.min.js"></script>
  <!-- UK sticky -->
  <script type="text/javascript" src="/static/js/components/sticky.min.js"></script>
  <!-- 本站js -->
  <script type="text/javascript" src="/static/js/script.js"></script>
  <!-- uk css-->
  <link rel="stylesheet" type="text/css" href="/static/css/uikit.min.css" />
  <!-- 基本样式 -->
  <link rel="stylesheet" type="text/css" href="/static/css/base.css" />
  <!-- 本站样式 -->
  <link rel="stylesheet" type="text/css" href="/static/css/main.css" />
  <!-- 代码高亮 -->
  <link rel="stylesheet" type="text/css" href="/static/css/highlight.css" />

  <!-- gitalk start (一个网页只需插入一次) -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
  <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
  <!-- gitalk end -->
</head>


<body>

  <header class="header" data-uk-sticky>
  <!-- 导航栏 -->
  <div class="uk-container uk-container-center">
    <div class="headwapper">
      <div class="navbar uk-float-left">
        <a class="uk-navbar-brand uk-hidden-small" href="http://loveshisong.cn"> 逆水行舟 -- Michael King's Blog </a>
        <a class="uk-visible-small uk-icon-home uk-icon-large" href="http://loveshisong.cn"></a>
      </div>
      <div class="navbar uk-float-right">
        <ul class="navbar-nav">
          <li><a href="/pages/archive.html" title="归档" class="uk-icon-folder uk-icon-small"></a></li>
          <li><a href="/pages/categories.html" title="目录分类" class="uk-icon-list uk-icon-small"></a></li>
          <li><a href="/pages/tags.html" title="标签" class="uk-icon-tags uk-icon-small"></a></li>
          <li><a href="/pages/about.html" title="About Me" class="uk-icon-user uk-icon-small"></a></li>
          <li><a href="https://github.com/rgkjhshi" title="Github" class="uk-icon-github uk-icon-small"></a></li>
          <li><a href="/feed.xml" title="RSS" class="uk-icon-rss uk-icon-small"></a></li>
        </ul>
      </div>
    </div>
  </div>
</header>
<!-- header end -->


  <div class="uk-container uk-container-center">
    <!-- <script type="text/javascript">
jQuery(function(){
	jQuery('#qrcode').qrcode({
        width: 150,
        height: 150,
        text: "http://loveshisong.cn/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2016-07-21-Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%89)-%E7%BD%91%E7%BB%9C%E5%92%8C%E6%95%B0%E6%8D%AE%E5%8D%B7.html"
    });
})
</script> -->
<!-- 日志默认模板 -->
<div class="uk-container content">
    <div class="page-title">
        <h1>Docker学习笔记(三):网络和数据卷</h1>
    </div>
    <div class="uk-grid">
        <div  class="uk-width-4-4">
            <!-- <div id="qrcode" class="uk-float-right uk-thumbnail"></div> -->
            <ul id="markdown-toc">
  <li><a href="#网络" id="markdown-toc-网络">网络</a>    <ul>
      <li><a href="#列出网络" id="markdown-toc-列出网络">列出网络</a></li>
      <li><a href="#查看网络信息" id="markdown-toc-查看网络信息">查看网络信息</a></li>
      <li><a href="#断开网络" id="markdown-toc-断开网络">断开网络</a></li>
      <li><a href="#创建网络" id="markdown-toc-创建网络">创建网络</a></li>
      <li><a href="#使用自定义网络创建容器" id="markdown-toc-使用自定义网络创建容器">使用自定义网络创建容器</a></li>
    </ul>
  </li>
  <li><a href="#数据卷" id="markdown-toc-数据卷">数据卷</a>    <ul>
      <li><a href="#添加数据卷" id="markdown-toc-添加数据卷">添加数据卷</a></li>
      <li><a href="#挂载本地目录" id="markdown-toc-挂载本地目录">挂载本地目录</a></li>
      <li><a href="#挂载文件" id="markdown-toc-挂载文件">挂载文件</a></li>
      <li><a href="#挂载容器中的数据卷" id="markdown-toc-挂载容器中的数据卷">挂载容器中的数据卷</a></li>
      <li><a href="#查看删除数据卷" id="markdown-toc-查看删除数据卷">查看删除数据卷</a></li>
      <li><a href="#volume的其他用法" id="markdown-toc-volume的其他用法"><code class="highlighter-rouge">volume</code>的其他用法</a></li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="网络">网络</h2>

<p>之前有个web程序的例子已经介绍过了端口, 这里说下网络</p>

<h3 id="列出网络">列出网络</h3>

<p>每个<code class="highlighter-rouge">Docker</code>引擎默认都会包含三个默认的网络, 我们可以这样查看:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
5fa52100eeb6        bridge              bridge              local
e3b7da4f14e9        host                host                local
6ddc3eda6788        none                null                local
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">NAME</code>为<code class="highlighter-rouge">bridge</code>的网络比较特殊, 新运行的容器默认都是在这个网络中, 除非指定是用别的网络</li>
</ul>

<h3 id="查看网络信息">查看网络信息</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ docker run -itd --name=networktest ubuntu
408cf6d9f25b9757c5d5fdfcd8c9a7133c7b888095c02b7b85d46f8df404b847
$ docker network inspect bridge
</code></pre></div></div>
<p>我们会得到类似于下面的描述</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span>
    <span class="p">{</span>
        <span class="s2">"Name"</span><span class="p">:</span> <span class="s2">"bridge"</span><span class="p">,</span>
        <span class="s2">"Id"</span><span class="p">:</span> <span class="s2">"5fa52100eeb64d58d5ec97b2f2267c78d700265d310030b0bc61e203367172d2"</span><span class="p">,</span>
        <span class="s2">"Scope"</span><span class="p">:</span> <span class="s2">"local"</span><span class="p">,</span>
        <span class="s2">"Driver"</span><span class="p">:</span> <span class="s2">"bridge"</span><span class="p">,</span>
        <span class="s2">"EnableIPv6"</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
        <span class="s2">"IPAM"</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">"Driver"</span><span class="p">:</span> <span class="s2">"default"</span><span class="p">,</span>
            <span class="s2">"Options"</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
            <span class="s2">"Config"</span><span class="p">:</span> <span class="p">[</span>
                <span class="p">{</span>
                    <span class="s2">"Subnet"</span><span class="p">:</span> <span class="s2">"172.17.0.0/16"</span><span class="p">,</span>
                    <span class="s2">"Gateway"</span><span class="p">:</span> <span class="s2">"172.17.0.1"</span>
                <span class="p">}</span>
            <span class="p">]</span>
        <span class="p">},</span>
        <span class="s2">"Internal"</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
        <span class="s2">"Containers"</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">"408cf6d9f25b9757c5d5fdfcd8c9a7133c7b888095c02b7b85d46f8df404b847"</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">"Name"</span><span class="p">:</span> <span class="s2">"networktest"</span><span class="p">,</span>
                <span class="s2">"EndpointID"</span><span class="p">:</span> <span class="s2">"87625c710a97b0e40dd79119d5002edd4c44f162ff1c2d4b85d9c87b0f43968e"</span><span class="p">,</span>
                <span class="s2">"MacAddress"</span><span class="p">:</span> <span class="s2">"02:42:ac:11:00:02"</span><span class="p">,</span>
                <span class="s2">"IPv4Address"</span><span class="p">:</span> <span class="s2">"172.17.0.2/16"</span><span class="p">,</span>
                <span class="s2">"IPv6Address"</span><span class="p">:</span> <span class="s2">""</span>
            <span class="p">}</span>
        <span class="p">},</span>
        <span class="s2">"Options"</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">"com.docker.network.bridge.default_bridge"</span><span class="p">:</span> <span class="s2">"true"</span><span class="p">,</span>
            <span class="s2">"com.docker.network.bridge.enable_icc"</span><span class="p">:</span> <span class="s2">"true"</span><span class="p">,</span>
            <span class="s2">"com.docker.network.bridge.enable_ip_masquerade"</span><span class="p">:</span> <span class="s2">"true"</span><span class="p">,</span>
            <span class="s2">"com.docker.network.bridge.host_binding_ipv4"</span><span class="p">:</span> <span class="s2">"0.0.0.0"</span><span class="p">,</span>
            <span class="s2">"com.docker.network.bridge.name"</span><span class="p">:</span> <span class="s2">"docker0"</span><span class="p">,</span>
            <span class="s2">"com.docker.network.driver.mtu"</span><span class="p">:</span> <span class="s2">"1500"</span>
        <span class="p">},</span>
        <span class="s2">"Labels"</span><span class="p">:</span> <span class="p">{}</span>
    <span class="p">}</span>
<span class="p">]</span>
</code></pre></div></div>
<p>我们可以这样检查容器的信息, 其中就有网络信息</p>

<p><strong>花括号之间没有空格!!</strong></p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 查看网络信息</span>
<span class="nv">$ </span>docker inspect <span class="nt">--format</span><span class="o">=</span><span class="s1">'{ {json .NetworkSettings.Networks}}'</span> networktest
<span class="o">{</span><span class="s2">"bridge"</span>:<span class="o">{</span><span class="s2">"IPAMConfig"</span>:null,<span class="s2">"Links"</span>:null,<span class="s2">"Aliases"</span>:null,<span class="s2">"NetworkID"</span>:<span class="s2">"5fa52100eeb64d58d5ec97b2f2267c78d700265d310030b0bc61e203367172d2"</span>,<span class="s2">"EndpointID"</span>:<span class="s2">"87625c710a97b0e40dd79119d5002edd4c44f162ff1c2d4b85d9c87b0f43968e"</span>,<span class="s2">"Gateway"</span>:<span class="s2">"172.17.0.1"</span>,<span class="s2">"IPAddress"</span>:<span class="s2">"172.17.0.2"</span>,<span class="s2">"IPPrefixLen"</span>:16,<span class="s2">"IPv6Gateway"</span>:<span class="s2">""</span>,<span class="s2">"GlobalIPv6Address"</span>:<span class="s2">""</span>,<span class="s2">"GlobalIPv6PrefixLen"</span>:0,<span class="s2">"MacAddress"</span>:<span class="s2">"02:42:ac:11:00:02"</span><span class="o">}}</span>
<span class="c"># 直接查看IP地址</span>
<span class="nv">$ </span>docker inspect <span class="nt">--format</span><span class="o">=</span><span class="s1">'{ {range .NetworkSettings.Networks}}{ {.IPAddress}}{ {end}}'</span> networktest
172.17.0.2
</code></pre></div></div>

<h3 id="断开网络">断开网络</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ docker network disconnect bridge networktest
</code></pre></div></div>
<p>把<code class="highlighter-rouge">networktest</code>这个容器从<code class="highlighter-rouge">bridge</code>网络中断开, 再次查看IP地址就没没有ip了</p>

<p>当然也可以重新连接</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ docker network connect bridge networktest
</code></pre></div></div>

<h3 id="创建网络">创建网络</h3>
<p>我们可以这样创建一个<code class="highlighter-rouge">bridge</code>网络</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ docker network create -d bridge my-bridge
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">-d</code>: driver value, 可以不写, 默认就是<code class="highlighter-rouge">bridge</code>; 最后面跟自己的driver名字</li>
</ul>

<h3 id="使用自定义网络创建容器">使用自定义网络创建容器</h3>

<p>在运行容器的时候可以通过传递参数<code class="highlighter-rouge">--network=my-bridge</code>来指定使用那个网络, 不传默认使用<code class="highlighter-rouge">bridge</code></p>

<p><strong>花括号之间没有空格!!</strong></p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker run <span class="nt">-d</span> <span class="nt">--network</span><span class="o">=</span>my-bridge <span class="nt">--name</span> db training/postgres
<span class="nv">$ </span>docker run <span class="nt">-d</span> <span class="nt">--name</span> web training/webapp python app.py
<span class="c"># db 使用的网络是 my-bridge</span>
<span class="nv">$ </span>docker inspect <span class="nt">--format</span><span class="o">=</span><span class="s1">'{ {range .NetworkSettings.Networks}}{ {.IPAddress}}{ {end}}'</span> db
172.18.0.2
<span class="c"># web 使用的网络是 bridge</span>
shisong<span class="nv">$ </span>docker inspect <span class="nt">--format</span><span class="o">=</span><span class="s1">'{ {range .NetworkSettings.Networks}}{ {.IPAddress}}{ {end}}'</span> web
172.17.0.2
</code></pre></div></div>
<p>我们可以打开容器<code class="highlighter-rouge">db</code>的终端, <code class="highlighter-rouge">ping</code>一下看看网是否通</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ docker exec -it db bash
root@822d3512fe8d:/# ping 172.17.0.2
PING 172.18.0.2 (172.18.0.2) 56(84) bytes of data.
64 bytes from 172.18.0.2: icmp_seq=1 ttl=64 time=0.114 ms
64 bytes from 172.18.0.2: icmp_seq=2 ttl=64 time=0.070 ms
^C
--- 172.18.0.2 ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 1006ms
</code></pre></div></div>
<p>如果我们把<code class="highlighter-rouge">web</code>容器也连接到<code class="highlighter-rouge">my-bridge</code>网络中, 则网络就通了</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker network connect my-bridge web
<span class="c"># 查看新的IP地址, 刚才的网络没断开, 所以会看到有两个网络, 两个IP地址(新的是172.18.0.3)</span>
<span class="nv">$ </span>docker inspect web
<span class="nv">$ </span>docker <span class="nb">exec</span> <span class="nt">-it</span> db bash
root@822d3512fe8d:/# ping 172.18.0.3
PING 172.18.0.3 <span class="o">(</span>172.18.0.3<span class="o">)</span> 56<span class="o">(</span>84<span class="o">)</span> bytes of data.
64 bytes from 172.18.0.3: <span class="nv">icmp_seq</span><span class="o">=</span>1 <span class="nv">ttl</span><span class="o">=</span>64 <span class="nb">time</span><span class="o">=</span>0.298 ms
64 bytes from 172.18.0.3: <span class="nv">icmp_seq</span><span class="o">=</span>2 <span class="nv">ttl</span><span class="o">=</span>64 <span class="nb">time</span><span class="o">=</span>0.112 ms
^C
<span class="nt">---</span> 172.18.0.3 ping statistics <span class="nt">---</span>
2 packets transmitted, 2 received, 0% packet loss, <span class="nb">time </span>999ms
</code></pre></div></div>

<h2 id="数据卷">数据卷</h2>
<p>数据卷(<code class="highlighter-rouge">data volume</code>)类似于linux系统中的挂载点</p>

<h3 id="添加数据卷">添加数据卷</h3>
<p>我们在使用<code class="highlighter-rouge">docker create</code>或<code class="highlighter-rouge">docker run</code>时可以通过<code class="highlighter-rouge">-v</code> flag来添加数据卷, 甚至可以多次使用<code class="highlighter-rouge">-v</code>来添加多个数据卷</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ docker run -d -P --name web -v /webapp training/webapp python app.py
</code></pre></div></div>

<p>上面是挂载了一个数据卷到容器的<code class="highlighter-rouge">/webapp</code>目录(必须是绝对路径), <code class="highlighter-rouge">/webapp</code>不存在则创建, 存在则覆盖(但不会删除原有的, 卸载时恢复原有的)</p>

<p>通过<code class="highlighter-rouge">docker inspect web</code>命令来查看添加数据卷的信息, 会有一段如下:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">...</span>
<span class="s2">"Mounts"</span><span class="p">:[</span>
    <span class="p">{</span>
        <span class="s2">"Name"</span><span class="p">:</span><span class="s2">"e30f9d5c1c8ffe1d02c8f1d758c5b0663c73ba46e8469e1e6ee14a9e5ee1784a"</span><span class="p">,</span>
        <span class="s2">"Source"</span><span class="p">:</span><span class="s2">"/var/lib/docker/volumes/e30f9d5c1c8ffe1d02c8f1d758c5b0663c73ba46e8469e1e6ee14a9e5ee1784a/_data"</span><span class="p">,</span>
        <span class="s2">"Destination"</span><span class="p">:</span><span class="s2">"/webapp"</span><span class="p">,</span>
        <span class="s2">"Driver"</span><span class="p">:</span><span class="s2">"local"</span><span class="p">,</span>
        <span class="s2">"Mode"</span><span class="p">:</span><span class="s2">""</span><span class="p">,</span>
        <span class="s2">"RW"</span><span class="p">:</span><span class="kc">true</span><span class="p">,</span>
        <span class="s2">"Propagation"</span><span class="p">:</span><span class="s2">""</span>
    <span class="p">}</span>
<span class="p">]</span>
<span class="p">...</span>
</code></pre></div></div>
<p>其中的<code class="highlighter-rouge">Source</code>就是我们挂载的数据卷,<code class="highlighter-rouge">Destination</code>是我们挂载到容器中的位置,<code class="highlighter-rouge">RW</code>是否可读写, 默认就是可读写</p>

<h3 id="挂载本地目录">挂载本地目录</h3>
<p>我们可以挂载本地目录, 也可以指定是只读还是可读写模式, <code class="highlighter-rouge">-v</code>后面的格式为<code class="highlighter-rouge">[local_path:]container-dir[:ro]</code>, 除了上面的那种形式, 还可以像下面这样:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ docker run -d -P --name web -v /src/webapp:/opt/webapp training/webapp python app.py
$ docker run -d -P --name web -v /src/webapp:/opt/webapp:ro training/webapp python app.py
</code></pre></div></div>
<p>不过在<code class="highlighter-rouge">OS X</code>和<code class="highlighter-rouge">windows</code>中, <code class="highlighter-rouge">Docker Engine</code>只有<code class="highlighter-rouge">/Users (OS X)</code>或<code class="highlighter-rouge">C:\Users (Windows)</code>的访问权限, 所以只能这样使用了:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># os x</span>
<span class="nv">$ </span>docker run <span class="nt">-v</span> /Users/&lt;path&gt;:/&lt;container path&gt; ...
<span class="c"># windows</span>
<span class="nv">$ </span>docker run <span class="nt">-v</span> /c/Users/&lt;path&gt;:/&lt;container path&gt; ...
</code></pre></div></div>

<p>另外, 还可以挂载某个名字的数据卷, <code class="highlighter-rouge">Docker</code>会创建一个给定名字的数据卷, 如:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ docker run -d -P --name web -v foo:/opt/webapp:ro training/webapp python app.py
</code></pre></div></div>
<p>通过<code class="highlighter-rouge">docker inspect web</code>得到的描述如下:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">...</span>
<span class="s2">"Mounts"</span><span class="p">:</span> <span class="p">[</span>
    <span class="p">{</span>
        <span class="s2">"Name"</span><span class="p">:</span> <span class="s2">"foo"</span><span class="p">,</span>
        <span class="s2">"Source"</span><span class="p">:</span> <span class="s2">"/var/lib/docker/volumes/foo/_data"</span><span class="p">,</span>
        <span class="s2">"Destination"</span><span class="p">:</span> <span class="s2">"/opt/webapp"</span><span class="p">,</span>
        <span class="s2">"Driver"</span><span class="p">:</span> <span class="s2">"local"</span><span class="p">,</span>
        <span class="s2">"Mode"</span><span class="p">:</span> <span class="s2">"ro"</span><span class="p">,</span>
        <span class="s2">"RW"</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
        <span class="s2">"Propagation"</span><span class="p">:</span> <span class="s2">"rprivate"</span>
    <span class="p">}</span>
<span class="p">]</span>
<span class="p">...</span>
</code></pre></div></div>

<h3 id="挂载文件">挂载文件</h3>

<p>我们可以挂载某个文件到容器中:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ docker run --rm -it -v ~/.bash_history:/root/.bash_history ubuntu /bin/bash
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">--rm</code>: 容器退出时自动删除容器</li>
</ul>

<p>上面就挂载了<code class="highlighter-rouge">bash_history</code>到容器中, 在容器里查看到原来本地机上的历史命令, 当退出容器的时候, 本地机会有刚才在容器里使用过的命令的历史.<br />
不过需要注意的是, 若是挂在了文件, 在容器里使用<code class="highlighter-rouge">vi</code>等编辑该挂在文件时, 会引起错误. 因此挂载这个文件的父目录是更好的选择.</p>

<h3 id="挂载容器中的数据卷">挂载容器中的数据卷</h3>
<p>挂载数据卷, 可以是匿名的也可以是命名的, 可以挂载本地目录也可以挂载本地文件, 还能挂载另一个容器中的数据卷. 我们可以通过参数<code class="highlighter-rouge">--volumes-from</code>指定数据卷来自于哪个容器, 可以多次使用<code class="highlighter-rouge">--volumes-from</code>来挂载多个数据卷</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 先创建一个叫 dbstore 的容器, 这个容器添加了数据卷</span>
<span class="nv">$ </span>docker create <span class="nt">-v</span> /dbdata <span class="nt">--name</span> dbstore training/postgres /bin/true
<span class="c"># 创建容器 db1, 指明数据卷来自于 dbstore</span>
<span class="nv">$ </span>docker run <span class="nt">-d</span> <span class="nt">--volumes-from</span> dbstore <span class="nt">--name</span> db1 training/postgres
<span class="c"># 创建容器 db2, 指明数据卷来自于 db1</span>
<span class="nv">$ </span>docker run <span class="nt">-d</span> <span class="nt">--volumes-from</span> db1 <span class="nt">--name</span> db2 training/postgres
</code></pre></div></div>

<h3 id="查看删除数据卷">查看删除数据卷</h3>
<p>上面例子中, 删除挂载数据卷的容器, 并不会删除挂载的数据卷, 除非在删除最后一个引用该数据卷的容器时指定<code class="highlighter-rouge">-v</code>标记</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 删除容器不会删除数据卷</span>
<span class="nv">$ </span>docker <span class="nb">rm </span>db1
<span class="c"># 添加 -v 由于不是最后一个引用数据卷的容器, 所以数据卷仍没被删除</span>
<span class="nv">$ </span>docker <span class="nb">rm</span> <span class="nt">-v</span> dbstore
<span class="c"># 删除最后一个引用数据卷的容器时,添加 -v , 数据卷被删除</span>
<span class="nv">$ </span>docker <span class="nb">rm</span> <span class="nt">-v</span> db2
</code></pre></div></div>
<p>如果删除了最后一个引用数据卷的容器时没有加<code class="highlighter-rouge">-v</code>, 将会出现<code class="highlighter-rouge">dangling</code>状态(悬挂,没人用了)的<code class="highlighter-rouge">volume</code>.</p>

<p><code class="highlighter-rouge">volume</code>有匿名和命名之分, 我们可以在创建容器时通过参数<code class="highlighter-rouge">--rm</code>指定, 当容器删除时, 对应的所有匿名<code class="highlighter-rouge">volume</code>也随着删除</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ docker run --rm -v /foo -v awesome:/bar --name test ubuntu
</code></pre></div></div>
<p>我们通过<code class="highlighter-rouge">-v</code>指定了一个匿名<code class="highlighter-rouge">volume</code>, 挂载到容器的<code class="highlighter-rouge">/foo</code>下, 还指定了一个命名为<code class="highlighter-rouge">awesome</code>的<code class="highlighter-rouge">volume</code>挂在到了<code class="highlighter-rouge">/bar</code>下, 容器运行完自动删除镜像(<code class="highlighter-rouge">--rm</code>)时, 匿名数据卷会被删除,而<code class="highlighter-rouge">awesome</code>并没有被删除.</p>

<p>另外我们可以通过 <code class="highlighter-rouge">docker volume</code>命令来查看管理所有的数据卷</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 查看所有 volume</span>
<span class="nv">$ </span>docker volume <span class="nb">ls</span>
<span class="c"># 查看 dangling 的 volume</span>
<span class="nv">$ </span>docker volume <span class="nb">ls</span> <span class="nt">-f</span> <span class="nv">dangling</span><span class="o">=</span><span class="nb">true</span>
<span class="c"># 删除 volume</span>
<span class="nv">$ </span>docker volume <span class="nb">rm</span> &lt;volume name&gt;
</code></pre></div></div>

<h3 id="volume的其他用法"><code class="highlighter-rouge">volume</code>的其他用法</h3>
<p>我们可以使用数据卷进行数据的备份、存储以及迁移等工作</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ docker run --rm --volumes-from dbstore -v $(pwd):/backup ubuntu tar cvf /backup/backup.tar /dbdata
</code></pre></div></div>
<p>从<code class="highlighter-rouge">dbstore</code>挂载了一个数据卷, 并且把本地目录挂在到了<code class="highlighter-rouge">/backup</code>下, 最后传递了一个<code class="highlighter-rouge">tar</code>命令, 把<code class="highlighter-rouge">dbdata volume</code>备份到<code class="highlighter-rouge">/backup</code>目录下的<code class="highlighter-rouge">backup.tar</code>文件里. 命令执行完, 容器停止并被自动移除了, 但是<code class="highlighter-rouge">dbdata volume</code>的数据被备份了.</p>

<p>然后我们可以创建一个新容器, 添加了一个匿名的<code class="highlighter-rouge">volume</code>在容器的<code class="highlighter-rouge">/dbdata</code>目录下:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ docker run -v /dbdata --name dbstore2 ubuntu /bin/bash
</code></pre></div></div>
<p>下面我们可以把刚才的备份文件解压到<code class="highlighter-rouge">dbstore2</code>的<code class="highlighter-rouge">volume</code>中, 从而达到转移的目的</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ docker run --rm --volumes-from dbstore2 -v $(pwd):/backup ubuntu bash -c "cd /dbdata &amp;&amp; tar xvf /backup/backup.tar --strip 1"
</code></pre></div></div>

<hr />

        </div>
    </div>

    <!-- gitalk评论框 start (一个网页只需插入一次) -->
    <!-- <div id="gitalk-container">
        <script type="text/javascript">
            var gitalk = new Gitalk({
                // gitalk的主要参数
                clientID: `9dc0d8d7df27d927c04e`,
                clientSecret: `48882a3ff7b351d89e7e67b4c61c7301d64afca2`,
                repo: `rgkjhshi.github.io`,
                owner: 'rgkjhshi',
                admin: ['rgkjhshi'],
                id: 'Docker学习笔记(三):网络和数据卷',
            });
            gitalk.render('gitalk-container');
        </script>
    </div> -->
    <!-- gitalk评论框 end -->
</div>

  </div>

  <!-- 回到顶部 -->
  <div class="page-scrollTop" data-toggle="tooltip" data-placement="top" title="Top">
    <a href="javascript:void(0);">
      <div class="arrow"></div>
      <div class="stick"></div>
    </a>
  </div>

  <footer class="footer">
    <!-- 导航栏 -->
    <div class="uk-container uk-container-center">
        <div class="uk-container footwapper">
            <div class="uk-grid">
                <div class="uk-width-1-3 uk-text-center">
                    <span class="foot-text"> 京ICP备14015515号-1 </span>
                </div>
                <div class="uk-width-1-3 uk-text-center">
                    <span class="foot-text">
                        <a href="http://www.amazingcounters.com"><img border="0" src="http://cc.amazingcounters.com/counter.php?i=3195706&c=9587431" alt="AmazingCounters.com"></a>
                    </span>
                </div>
                <div class="uk-width-1-3 uk-text-center">
                <span class="foot-text"> <i class="uk-icon-copyright"></i>2015 Michael King. </span>
                </div>
                <div class="uk-hidden">
                    <span class="foot-text">
                        <!-- cnzz统计工具 -->
                        <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1254308303'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s4.cnzz.com/z_stat.php%3Fid%3D1254308303%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));</script>
                    </span>
                </div>
            </div>
        </div>
    </div>
</footer>
<!-- footer end -->


</body>

</html>
