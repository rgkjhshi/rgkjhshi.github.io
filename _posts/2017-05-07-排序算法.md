---
layout: blog
title:  排序算法
date: 2017-05-07
category: 编程技术
tag: Java
---
基本的排序算法



*****

* TOC
{:toc}

*****

## 插入类排序
插入类排序基本思想在于, 每次将一个元素插入到前面已经排好序的子序列中, 包括`直接插入排序`、`折半插入排序`、`希尔排序`

### 直接插入排序
* 基本思想: 一个数组, 左边有序(起始只有一个元素), 把右边元素依次插入到左边的有序表
* 算法步骤:
  1. 找到元素`L[i]`在左边有序表`L[1 ~ i-1]`的插入位置`k`
  2. 将`L[k ~ i-1]`所有元素全部后移一个位置(必须临时存放原来的`L[i]`)
  3. 把元素 `L(i)`复制到`L[k]`
* 算法描述:

~~~java
    // 直接插入排序
    public void insertSort(int A[], int n) {
        int i, j;
        for (i = 1; i <= n - 1; i++) {    // 依次将A[1]~A[n-1]插入到前面已排序序列(初始的有序表只有A[0])
            if (A[i] < A[i - 1]) {        // 若A[i]小于前驱, 需将A[i]插入有序表
                int tmp = A[i];           // 临时存放待插入元素
                for (j = i - 1; tmp < A[j]; --j) {  // 向前查找待插入位置
                    A[j + 1] = A[j];      // 向后挪位
                }
                A[j + 1] = tmp;           // 复制到插入位置
            }
        }
    }
~~~

* 空间复杂度: `O(1)`, 借助于了一个临时存放单元
* 时间复杂度: `O(n^2)`, 最好情况下, 元素已经有序, 时间复杂度为`O(n)`
* 稳定性: 稳定
* 适用场景: 基本有序

### 折半插入排序

* 基本思想: 也是左边有序, 右边依次插入有序表, 不同的是找插入位置`k`时, 使用折半查找法
* 算法描述:

~~~java
    // 折半插入排序(递增排序)
    public void insertSort(int A[], int n) {
        for (int i = 1; i <= n - 1; i++) {   // 依次将A[1]~A[n-1]插入到前面已排序序列
            int tmp = A[i];                  // 临时存放待插入元素
            int low = 0;                     // 折半查找的范围
            int high = i - 1;
            while (low <= high) {            // 折半查找(low == high 总会发生)
                int mid = (low + high) / 2;  // 取中间点
                if (A[mid] > tmp) {          // 查找左半子表
                    high = mid - 1;
                } else {                     // 查找右半子表
                    low = mid + 1;
                }
            }
            // 程序到这里会出现 high + 1 == low
            for (int j = i - 1; j >= high + 1; --j) {  // 统一移动元素, 空出插入位置
                A[j + 1] = A[j];  // 向后挪位
            }
            A[high + 1] = tmp;
        }
    }

~~~

* 空间复杂度: `O(1)`
* 时间复杂度: `O(n^2)`, 仅减少了比较次数, 大约为`O(nlogn)`(`log`表示以2为底的对数), 且比较次数与初始顺序无关
* 稳定性: 稳定
* 适用场景: 数据量不大

******

## 交换类排序
交换类排序的基本思想在于, 根据两个元素的比较结果来交换两个元素在序列中的位置, 包括`冒泡排序`和`快速排序`

### 冒泡排序
* 基本思想: 从后向前(也可从前向后)依次比较相邻两元素, 若为逆序则交换, 这样一趟冒泡会把最小的元素交换到第一个位置; 下一趟冒泡时, 第一个元素就不再参与了, 这样每次都把最小元素交换到前面, 总共进行`n-1`趟冒泡就可以了.
* 算法描述:

~~~java
    // 冒泡排序(递增排序)
    public static void bubbleSort(int A[], int n) {
        for (int i = 0; i < n - 1; i++) {       // 总共需要n-1趟冒泡
            boolean flag = false;               // 用于记录本趟是否发生了交换, 只要有一趟没发生交换, 就说明已经有序了
            for (int j = n - 1; j > i; j--) {   // 一趟冒泡
                if (A[j - 1] > A[j]) {          // 相邻元素比较
                    swap(A[j-1], A[j]);         // 交换
                    flag = true;
                }
            }
            if (!flag) {  // 如果这趟没发生交换, 说明已经有序了
                return;
            }
        }
    }
~~~

* 空间复杂度: `O(1)`
* 时间复杂度: `O(n^2)`, 最好情况下, 元素已经有序, 时间复杂度为`O(n)`
* 稳定性: 稳定
* 适用场景: 基本有序
* 另附关于交换两个单元的方法:

~~~java
    // 借助临时单元
    int tmp = a;
    a = b;
    b = tmp;
    // 直接交换
    a = a + b;
    b = a - b;
    a = a - b;
    // 位操作交换
    a = a ^ b;
    b = a ^ b;
    a = a ^ b;
~~~


### 快速排序
* 基本思想: 基于分治法, 在n个元素中任取一个元素`pivot`(一般为第一个元素)作为基准, 一趟排序后把数据分成两部分, 左边`L[0 ~ k-1]`和 右边`L[k+1 ~ n-1]`, 使得左边元素都小于`pivot`, 右边都大于`pivot`, 而`pivot`直接复制到`L[k]`上, 这个过程成为一趟快排; 然后对左子表和右子表分别进行上述过程, 直到每部分只有一个元素或为空为止, 即所有元素都放在了最终位置上.
* 算法描述:

~~~java
    // 快速排序
    public static void quickSort(int A[], int left, int right) {
        if (left < right) {  // 跳出递归的条件
            int pivotPos = partition(A, left, right);  // 划分函数, 找到pivot的位置
            quickSort(A, left, pivotPos - 1);          // 排序左子表
            quickSort(A, pivotPos + 1, right);         // 排序右子表
        }
    }
    // 划分函数, 一趟排序的过程
    private static int partition(int A[], int left, int right) {
        int pivot = A[left];           // 任取一个元素作为基准, 这里用第一个元素作为基准
        while (left < right) {         // 循环跳出的条件
            while (left < right && A[right] >= pivot) --right;   // 从后向前找到第一个小于pivot的元素
            A[left] = A[right];        // 把小于pivot的元素换到左边
            while (left < right && A[left] <= pivot) ++left;     // 从前向后找到第一个大于pivot的元素
            A[right] = A[left];        // 把大于pivot的元素换到右边
        }
        // 跳出循环总会有 left == right
        A[left] = pivot;
        return left;
    }
~~~

* 空间复杂度: `O(n)`, 栈深度最好为`log(n+1)`, 最坏为`n-1`, 平均栈深度`O(logn)`
* 时间复杂度: 最好`O(nlogn)`, 最坏(有序时最坏)`O(n^2)`, 平均接近最好情况; `快排是是所有排序算法中平均性能最优的`
* 稳定性: 不稳定

******

## 选择类排序
选择类排序的基本思想在于, 每趟都从待排序列中选取一个最小值作为序列的第i个元素,直到第`n-1`趟, 待排序列只剩下一个元素. 包括`简单选择排序`和`堆排序`

### 简单选择排序
* 基本思想: 第`i`趟从`L[i ~ n]`中选择关键字最小的元素与`L[i]`交换, 这样每趟都可确定一个元素的最终位置, 经过`n-1`趟就可以使整个序列有序.
* 算法描述:

~~~java
    // 简单选择排序
    public void selectSort(int A[], int n) {
        for (int i = 0; i < n - 1; i++) {      // 一共进行 n-1 趟
            int min = i;                       // 记录最小元素位置
            for (int j = i + 1; j < n; j++) {  // 从 A[i+1 ~ n-1]中选择最小元素
                if (A[j] < A[min]) {           // 更新最小元素位置
                    min = j;
                }
            }
            if (min != i) {                    // 最小的与第i个位置交换
                swap(A[i], A[min]);
            }
        }
    }
~~~

* 空间复杂度: `O(1)`
* 时间复杂度: `O(n^2)`
* 稳定性: 不稳定

### 堆排序
* 特点: 在排序过程中, 把`L[1 ~ n]`看成是一颗`完全二叉树`的顺序存储结构, 利用完全二叉树中父节点和子节点的内在关系, 在当前无需区中选择关键字最大(或最小)的元素
* 完全二叉树: 若二叉树除最后一层外, 其它各层的结点数都达到最大个数, 最后一层所有的结点都连续集中在最左边, 这就是完全二叉树
* 小根堆: `L[1~n]`满足 `L[i]<=L[2i]`且`L[i]<=L[2i+1]`
* 大根堆: `L[1~n]`满足 `L[i]>=L[2i]`且`L[i]>=L[2i+1]`
* 示例:

~~~java
// 序列为:
16, 14, 10, 8, 7 , 9 , 3, 3, 4
// 表示的大根堆为:
          16
        +     +
     14         10
    +   +     +    +  
  8      7   9      3
 + +
2   4
~~~
* 算法思想: 

~~~java
~~~

* 空间复杂度: `O(1)`
* 时间复杂度: `O(n^2)`
* 稳定性: 不稳定

******
