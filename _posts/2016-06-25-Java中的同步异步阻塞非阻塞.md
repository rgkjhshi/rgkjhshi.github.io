---
layout: blog
title:  Java中的同步异步阻塞非阻塞
date:   2016-06-25
category: 编程技术
tag: Java
---
内容涉及OS的IO模型, Java的同步与异步, 阻塞与非阻塞, BIO、NIO、AIO




*****

* TOC
{:toc}

*****

## 同步与异步

同步就是一直在做某件事儿, 调用某个功能时, 这个功能没有结果之前, 这个调用就不返回。 比如洗衣服, 把衣服放在洗衣机里没有洗好之前就一直在那里看着它洗, 这就是同步(这个例子并不好, 人和洗衣机是两个主体, 我觉得同步应该是要洗一堆衣服, 自己动手洗, 没洗好之前就一直洗, 直到洗完才能做别的事情, 这样理解同步更好)

异步就是做某件事儿的同时也做了其他事, 调用某个功能时, 不用立即得到结果, 可以先处理别的功能, 有结果之后被调用方通知调用者来处理这个结果。 比如洗衣服, 把衣服放到洗衣机里洗, 自己可以先做别的事情, 衣服洗好了, 洗衣机会响铃通知, 这个时候就可以再去把衣服拿出来

*****

## IO模型

要理解阻塞和非阻塞, 可以先了解下IO操作机制。IO机制是操作系统层面的, Java可以通过JVM发起系统调用进行IO操作.

先介绍下Linux OS中常见的IO模型:select, poll, epoll

* select模型: 网络通信被linux操作系统抽象成文件读写, 通常由设备驱动程序提供, 驱动知道自身数据是否可用. 这些设备描述符由一个数组管理, 数组是有长度的, 32位机上限1024, 64位机上限2048. 每次select请求时都会线性遍历数组看是否有可用的文件描述符, 若一个也没有则睡眠, 直到超时或有可用资源后被唤醒, 然后重新遍历select数组找到可用的文件描述符.
* poll模型: 与select类似, 把select数组采用链表实现, 因此没了最大数量的限制
* epoll模型: 基于事件回调机制, 回调时直接通知进程, 无须使用某种方式来查看状态.

## 阻塞与非阻塞

`阻塞与非阻塞`貌似很容易和`同步与异步`混淆。我们可以这么来看.

阻塞的线程通常是处于`BLOCKED`状态(BIO中的`read()`操作时, 线程阻塞是JVM配合OS完成的, 此时Java获取到线程的状态仍是`RUNNABLE`但它确实已经被阻塞了)
同步是指步骤需要一步步来完成, 像代码一条条执行, 而异步可以没执行完当前代码之前就执行下一行代码, 即做当前任务的同时也能做别的任务(当前任务可以交给别的线程同时执行). 不过关键要注意的是, 同步异步中的同步跟多线程同步使用`synchronized`进行同步, 这俩词虽然是一样的, 但说的完全不是一会儿事儿.

所以`阻塞与非阻塞`说的是怎么通信, 是挂起还是不挂起, 有没有回调; `同步与异步`说的是怎么干活, 按部就班顺序干, 还是不按顺序一起同时干.

传统的IO发起后线程被挂起, IO返回时接收结果的时间比运行的时间还要长. 所以可以用一个线程专门监视IO的返回状况(通过system call 获取一些状态), 发现IO的数据准备好时采用某种方式来处理(可以分配一个线程处理, 若处理比较简单可以也使用这个线程处理). JDK1.4 提供了NIO(New I/O), 使用`SocketChannel`代替原来的`Socket`, 它就是非阻塞IO, 它通过select选择器来进行系统调用。
不过这样的处理, 中间有一个将数据从内核区拷贝到进程内的过程是同步的, 即这个过程是程序自己处理的(占用了本身线程的时间), 所以NIO是同步非阻塞的。如果这个拷贝数据到程序空间的过程也是别人来做, 不占用本身线程的时间, 这就是异步模型了.

### BIO

`BIO`即`Blocking I/O`(阻塞 I/O), 这种模型中程序先通过系统调用(System Call)发送请求给内核(Kernel), 然后由内核去进行通信, 如果系统调用是读操作的话, 在内核准备好数据之前这个线程是被挂起的, 直到数据在内核中准备好.

整个过程可分为两个阶段:

1. 等待I/O数据返回. 这取决于IO目标返回数据的速度, 如网络IO时看网速和数据本身的大小
2. 返回的数据先被填充到内核(Kernel)缓冲区里, 然后从内核区拷贝到进程内. 这个过程完成后程序才能向下执行.

BIO整个过程如下图:

![BIO]({{ "/static/images/BIO.png"  | prepend: site.baseurl }} "BIO")

* BIO的特点就是在IO执行的两个阶段都被block了

### NIO

`NIO`即`Non-Blocking I/O`(非阻塞 I/O), 与BIO的明显区别是, 发起第一次System Call请求后, 线程并没有被阻塞, 它反复检查数据是否准备好, 把原来大块不能用的阻塞时间分成了许多"小阻塞"(检查), 所以进程不断有机会被执行.这个检查有没有准备好数据的过程有点类似于"轮询".

线程一直在反复查看有没有数据准备好, 这似乎在空耗CPU, 看起来效率更低, 这就要看到底怎么使用了. 实际上每次查看的动作比较简单, 可以只用一个专门的线程对很多事件进行监听, 设计好检测频率就能达到高效且节省资源的目的.

NIO整个过程如下图:

![NIO]({{ "/static/images/NIO.png"  | prepend: site.baseurl }} "NIO")

* NIO的特点就是程序需要不断的主动询问内核数据是否准备好。第一个阶段非阻塞, 第二个阶段阻塞

### 多路复用IO

NIO中轮询操作是用户线程进行的, 如果把这个任务交给其他线程, 则用户线程就不用这么费劲的查询状态了. 多路复用(`Multiplexing I/O`)调用系统级别的`select`或`poll`模型, 由系统进行监控IO状态. select轮询可以监控许多socket的IO请求, 当有一个socket的数据准备好时就可以返回可读状态. 用户线程有一段时间是阻塞的, 与普通非阻塞IO不一样的是, select不是等到所有数据准备好才返回, 而是只要有一个准备好就返回.

Java 1.4提供的的NIO就是采用了这种方式, 在套接字上提供selector选择机制, 当发起`select()`时会阻塞等待至少一个事件返回.

多路复用IO过程图:

![Multiplexing_IO]({{ "/static/images/Multiplexing_IO.png"  | prepend: site.baseurl }} "Multiplexing_IO")

* 多路复用IO的特点是用户进程能同时等待多个IO请求,系统来监控IO状态,其中的任意一个进入读就绪状态,select函数就可以返回.

### 小结

上面这三种模式, 用户进程发起系统调用, 等待数据到来的过程中, 直接等待、轮询 或 select轮询。第一个过程有的阻塞, 有的不阻塞, 有的可以阻塞又可以不阻塞. 第二个过程都是阻塞的。从整个IO过程来看, 他们都是顺序执行的, 因此都属于同步模型.

### AIO
`AIO`即`Asynchronous I/O`(异步 I/O), 这是Java1.7引入的`NIO 2.0`中用到的. 整个过程中, 用户线程发起一个系统调用之后无须等待, 可以处理别的事情. 由操作系统等待接收内容, 接收后把数据拷贝到用户进程中, 最后通知用户程序已经可以使用数据了, 整个过程都是非阻塞的. 相当于数据"送货上门"了. 这个过程中系统帮我们处理IO, 用户线程可以同时处理别的事情, 这属于异步模型.

AIO整个过程如下图:

![AIO]({{ "/static/images/AIO.png"  | prepend: site.baseurl }} "AIO")

AIO是异步的, 我们怎么进一步加工处理结果呢? Java在这个模型中提供了两种方法:

1. 一种是基于"回调", 我们可以实现`CompletionHandler`接口, 在调用时把回调函数传递给对应的API即可
2. 另一种是返回一个`Future`. `isDone()`可查看是否已经准备好数据, 这有点类似于NIO查询的意思； `get()`方法是等到数据完成返回数据, 有点类似于BIO的意思.



*****
